我们可以编写些程序、编译、运行。

优点：友好的语法、面向对象、内存管理、跨平台可移植。/write-once,run-anywhere

Java的工作方式：编写源代码-编译器检查错误并翻译成字节码-java虚拟机读取并执行字节码，转换成平台可以理解的形式

类存于源文件里面，方法存于类中，语句存于方法中。

类是对象的蓝图，java中的绝大多数都是对象。

错误语法：

    int x = 1;
    while(x){}

java中的整型与boolean两种类型并不相容，只能用如下的boolean变量来测试：
    
    boolean isHot= true;
    while(isHot){}

类不是对象，是对象的蓝图。是用来创建对象的模型。会告诉虚拟机如何创建某种类型的对象。
对象是靠类的模型塑造出来的。

main的两种用途：测试真正的类；启动你的java应用程序。

java的程序在执行期是一组会互相交谈的对象。

java程序是由一组类组成，其中一个类会带有启动用的main方法。

对象引用变量保存的是存取对象的方法。

Dog d = new Dog() #代表取得Dog对象的方法以字节形式放进变量中。对象本身并没有放进变量中。

任意一个java虚拟机，所有的引用大小都一样。但不同的虚拟机可能会以不同的方式来表示引用，因此某个java虚拟机的引用可能会大于或小于另外一个虚拟机的引用。

java不是c。不可以对引用变量进行运算。

类所描述的是对象知道什么与执行什么。在编写类时，你是在描述java虚拟机应该如何制作该类型的对象。

封装会对实例变量加上绝对领域。

封装：强迫其他程序一定得经过setter，如此setter就能检查参数并判断是否可以执行。

实例变量与局部变量的区别：

实例变量声明在类内，局部变量声明在方法中，局部变量在使用前必须被初始化。

实例变量永远都会有默认值。int类型的变量默认值为0,float类型为0.0，booleans为false，对象引用默认值为null;

局部变量没有默认值，如果在变量被初始前就要使用的话，编译器会显示错误。

变量的比较：

使用"=="来比较两个主数据类型，或者判断两个引用是否引用同一个对象。

使用equals()来判断两个对象是否在意义上相等。（比如两个string对象是否带有相同的字节组合）。

"=="只用来比对两个变量的字节组合，实质所表示的意义则不重要。字节组合要么相等，要么就是不相等。如：
    
    int a = 3; 
    byte b =3;
    if(a == b){}  //由于字节组合相等，此处为true

实例变量应该要标记为private，并通过getter与setter来存取。如此才能有机会确保实例变量值会落在合法的范围内。

同for循环相比，while循环只有boolean测试，没有内建的初始化和重复表达式。

while适合用在不知道要循环几次的循环上，若知道执行几次，则使用for循环比较容易阅读。

    int i = 0;  //初始化
    while(i<8){
        System.out.println(i); 
        i++;   //计数器递增
    }

加强版的for循环

    for(String name:nameArray){}

将String转换成int
    
    Integer.parseInt(string)

"System.out.println(++y);"此处标准输出内部对y进行的运算也会对当前所在语句块当中的y产生影响，效果等同于"++y;"

数组无法改变大小。对象有状态和行为，无法对数组调用方法，比如不能从数组中删除元素，

ArrayList是个Java API的类，是个高级类，是个对象，可以确实地把引用删除掉，也可以动态的改变大小。在运用基本数据类型的时候，数组会比ArrayList快。

在使用ArrayList时，你只是在运用ArrayList类型的对象，因此跟运用其他对象一样，你会使用"."运算符调用它的方法。

使用数组时，你会用特殊的数组语法来操作，这样的语法只能用在数组上。虽然数组也是对象，但是它有自己的规则，你无法调用它的方法，最多只能存它的Length实例变量。

虽然ArrayList只能携带对象而不是primitive主数据类型，但编译器能够自动地将主数据类型包装成Object以存放在ArrayList中。

##ArrayList与一般数组的比较

创建：
    
    ArrayList<String> mylist = new ArrayList<String>();    //不需指定大小，会在加入或删除元素时自动调整大小
    String[] mylist = new String[3];    //创建时就必须确定大小

添加元素：

    String s1 = new String("string"); mylist.add(s1);   //可以使用add(int,Object)指定索引值，也可以让它自行管理
    String s1 = new String("string"); mylist[0] = s1;   //存放对象给一般数组时必须指定位置

获取个数：

    int theSize = mylist.size();
    int theSize = mylist.length;

根据位置获取元素：

    Object o = mylist.get(1);
    String o = mylist[1];   //方括号是只用在数组上的特殊语法

删除元素：

    mylist.remove(1); mylist.remove(s1);
    mylist[1] = null;

判断元素是否在集合中：

    boolean isIn = mylist.contains(s1);
    //数组：
    boolean isIn = false;
    for(String item : mylist){
        if(s1.equals(item)){
            isIn = true;
            break;
        }
    }


短运算符：&&

避免调用内容为null:if(refVar != null && refVar.isValidType()){},前者为假是后面就不执行了。

&与|运算符使用在boolean表达式时，会强制虚拟机一定要计算运算符两边的算式。但这两个运算符通常是用来做位的运算。

在java的api中，类是被包装在包中的。要使用api中的类，你必须知道它被放在哪个包中。

以javax开头的包以前曾经是扩展，后来才被包含进标准库。

类会用包来组织。类有完整的名称，那是由包的名称与类的名称所组成的。ArrayList事实上叫做java.util.ArrayList。

除了java.lang之外，使用到其他包的类都需要指定全名。也可以在原始程序代码的最开始部分下import指令来说明所使用到的包。

java.lang是个预先被引用的基础包。所以不必import进java.lang.System,java.lang.String等class。

import与c语言的include并不相同，运用import只是帮你省下每个类前面的包名称而已。程序不会因为用了import而变大或变慢。

继承：实例变量无法被覆盖掉是因为不需要，它们并没有定义特殊的行为。

多态：

    Animal[] animals = new Animal[3];
    animals[0] = new Dog();
    animals[1] = new Cat();
    animals[2] = new Wolf();
    for(int i=0;i<animals.length;i++){
        animals[i].eat();   //当i为0的时候会调用Dog的eat，当i为1的时候会调用Cat的eat。        
    }

java中除了内部类之外，没有私有类这样的概念。有3种方法可以防止某个类被作出子类。

第一类是存取控制。就算类不能被标记为私有，但它还是可以不标记为公有。非公有的类只能被同一个包的类作出子类。

第二类是使用final这个修饰符，这表示它是继承树的末端，不能被继承。（如果需要安全，确保方法都会是你写出的版本，此时就需要final）

第三类是让类只拥有private的构造程序。

如果想要防止特定的方法被覆盖，可以将该方法标识上final这个修饰符。将整个类标识成final表示没有任何的方法可以被覆盖。

子类的参数同父类的必须一样，返回类型必须要兼容（返回一样的类型或该类型的子集）。

子类的存取权限必须跟父类相同，或者更为开放。比如：不能覆盖一个公有的方法并将它标记为私有。

##方法的重载

重载的意义是两个方法的名称相同，但参数不同。所以，重载与多态、与继承毫无关系。

重载可以有同一方法的多个不同参数版本以方便调用。

##接口

接口是一种100%的抽象类，也就是无法初始化的类。接口是多态和java的重点。

抽象类：不能被"new"出来的类，不能被初始化，不能创建任何类型的实例。

但是还可以用这种抽象的类型作为引用类型，给多态使用。

设计抽象类的方法：在类的声明前加上抽象类的关键词：abstract。

不是抽象的类就被称为具体类。查阅Java API你会发现其中有很多的抽象类，特别是GUI的函数库中更多。GUI的组件类是按钮、滚动条等类的父类，你只会对组件下的具体子类作初始化动作。

除了类之外，也可以将方法标记为abstract。抽象的类代表此类必须要被extend过，抽象的方法代表此方法一定要被覆盖过。

抽象类中的某些行为（方法）无法兼顾到所有的子类，所以会在各子类中单独定义。（此处可以用到抽象方法）

抽象的方法没有实体。（因为你已经知道编写出抽象方法的程序代码没有意义，所以不会含有方法）

public abstract void eat();    //没有方法体，直接以分号结束。

如果你声明出一个抽象的方法，就必须将类也标记为抽象的。你不能在非抽象类中拥有抽象方法。就算只有一个抽象的方法，此类也必须标记为抽象的。

抽象方法无法实现方法的内容，意义在于定义出一组子型共同的协议。

抽象的好处：多态！想达成的目标是要使用父型作为方法的参数、返回类型或数组的类型。通过这个机制你可以加入新的子型到程序中，却又不必重写或修改处理这些类型的程序。因此多态的好处就在于所有子型都会有那些抽象的方法。

抽象的方法没有内容，它只是为了标记出多态而存在。这表示在继承树结构下的第一个具体类必须要实现出所有的抽象方法。java很注重你的具体子类有没有实现这些方法。

必须实现所有的抽象的方法。

java中的所有类都是从Object(java.lang.Object)这个类继承出来的。

任何从ArrayList<Object>取出的东西都会被当作Object类型的引用而不管它原来是什么。

编译器是根据引用类型来判断有哪些Method可以调用，而不是根据Object确实的类型。

不管实际上所引用的对象是什么类型，只有在引用变量的类型就是带有某方法的类型时才能调用该方法。

Object引用变量在没有类型转换的情况下不能赋值给其他的类型，若堆上的对象类型与所要转换的类型不兼容，则此转换会在执行期间产生异常。

类型转换的例子：Dog d = (Dog) x.getObject(aDog);

java不允许多重继承，因为那样会有致命方块的问题。



接口的定义：
    
    public interface Pet{
        public abstract void beFriendly();  //接口的方法带有public和abstract的意义，这两个修饰符属于选择性的。
        public abstract void play();    //接口的方法没有内容
    }

接口的实现：

    public class Dog extends Canine implements Pet{
        public void beFriendly(){...}   //必须在这里实现出Pet所有的方法
        public void play(){...}
    }

不同继承树的类也可以实现相同的接口。

类可以实现多个接口（extend只能有一个，implement可以有好多个；类来自单亲家庭，但可以扮演多重角色）

    public class Dog extends Animal implements Pet, Saveable, Paintable{...}

当需要定义一群子类的模板，又不想让程序员初始化此模板时，设计出抽象的类给他们用。

如果想要定义出类可以扮演的角色，使用接口。

在子类中指定下面的命令，父类的方法就会执行：

    super.xxxxx();















































































